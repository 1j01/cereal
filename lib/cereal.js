// Generated by CoffeeScript 1.9.2
(function() {
  var array, dejsonify, generateDecodeWork, generateEncodeWork, isPrimitive, jsonify, nu, object, prim, ref, undef;

  isPrimitive = function(obj) {
    return obj !== Object(obj);
  };

  undef = 0;

  nu = 1;

  prim = 2;

  object = 3;

  array = 4;

  ref = 5;

  generateEncodeWork = function(obj, target) {
    var i, len, name, names, results;
    names = Object.keys(obj);
    results = [];
    for (i = 0, len = names.length; i < len; i++) {
      name = names[i];
      target[name] = [];
      results.push([target[name], obj[name]]);
    }
    return results;
  };

  jsonify = function(obj) {
    var item, refIdx, root, seen, seenIdx, target, worklist;
    root = [];
    seen = [];
    seenIdx = 0;
    worklist = [[root, obj]];
    while (worklist.length > 0) {
      item = worklist.shift();
      target = item[0];
      obj = item[1];
      if (obj === void 0) {
        target[0] = undef;
      } else if (obj === null) {
        target[0] = nu;
      } else if (isPrimitive(obj)) {
        target[0] = prim;
        target[1] = obj;
      } else {
        refIdx = seen.lastIndexOf(obj);
        if (refIdx === -1) {
          refIdx = seenIdx;
          seenIdx += 1;
          seen[refIdx] = obj;
          target[1] = refIdx;
          target[2] = {};
          if ('cerealise' in obj && typeof obj.cerealise === 'function') {
            obj = obj.cerealise();
          }
          if (Object.prototype.toString.apply(obj) === '[object Array]') {
            target[0] = array;
          } else {
            target[0] = object;
          }
          worklist = (generateEncodeWork(obj, target[2])).concat(worklist);
        } else {
          target[0] = ref;
          target[1] = refIdx;
        }
      }
    }
    return root;
  };

  generateDecodeWork = function(obj, target) {
    var i, len, name, names, results;
    names = Object.keys(obj);
    results = [];
    for (i = 0, len = names.length; i < len; i++) {
      name = names[i];
      obj[name].unshift(name);
      obj[name].unshift(target);
      results.push(obj[name]);
    }
    return results;
  };

  dejsonify = function(obj) {
    var field, item, root, seen, target, worklist;
    root = {};
    seen = [];
    worklist = [obj];
    obj.unshift('value');
    obj.unshift(root);
    while (worklist.length > 0) {
      item = worklist.shift();
      target = item[0];
      field = item[1];
      switch (item[2]) {
        case undef:
          target[field] = void 0;
          break;
        case nu:
          target[field] = null;
          break;
        case prim:
          target[field] = item[3];
          break;
        case object:
          target[field] = {};
          seen[item[3]] = target[field];
          worklist = (generateDecodeWork(item[4], target[field])).concat(worklist);
          break;
        case array:
          target[field] = [];
          seen[item[3]] = target[field];
          worklist = (generateDecodeWork(item[4], target[field])).concat(worklist);
          break;
        case ref:
          target[field] = seen[item[3]];
          if (target[field] === void 0) {
            throw new Error("Decoding error: referenced object not found");
          }
          break;
        default:
          throw new Error("Decoding error: unhandled object type code " + item[2]);
      }
    }
    return root.value;
  };

  this.Cereal = {
    stringify: function(obj) {
      return JSON.stringify(jsonify(obj));
    },
    parse: function(str) {
      return dejsonify(JSON.parse(str));
    }
  };

  if (typeof module !== "undefined" && module !== null) {
    module.exports = Cereal;
  }

}).call(this);
